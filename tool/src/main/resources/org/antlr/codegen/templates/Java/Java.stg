/*
 [The "BSD license"]
 Copyright (c) 2010 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import "org/antlr/codegen/templates/common.stg"

javaTypeInitMap ::= [
	"int":"0",
	"long":"0",
	"float":"0.0f",
	"double":"0.0",
	"boolean":"false",
	"byte":"0",
	"short":"0",
	"char":"0",
	default:"null" // anything other than an atomic type
]

javaPrimitiveTypeCastMap ::= [
	"int":     "Integer",
	"long":    "Long",
	"float":   "Float",
	"double":  "Double",
	"boolean": "Boolean",
	"byte":    "Byte",
	"short":   "Short",
	"char":    "Char"
]

// System.Boolean.ToString() returns "True" and "False", but the proper C# literals are "true" and "false"
// The Java version of Boolean returns "true" and "false", so they map to themselves here.
booleanLiteral ::= [
	"True":"true",
	"False":"false",
	"true":"true",
	"false":"false",
	default:"false"
]

// L A N G U A G E   E L E M E N T S

// As the common.stg uses the Java elements for defaults, we don't need to
// specify any here.

/** The overall file structure of a recognizer; stores methods for rules
 *  and cyclic DFAs plus support code.
 */
outputFile(LEXER,PARSER,TREE_PARSER, actionScope, actions,
           docComment, recognizer,
           name, tokens, tokenNames, rules, cyclicDFAs,
	   bitsets, buildTemplate, buildAST, rewriteMode, profile,
	   backtracking, synpreds, memoize, numRules,
	   fileName, ANTLRVersion, generatedTimestamp, trace,
	   scopes, superClass, literals) ::=
<<
// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
<actions.(actionScope).header>

<@imports>
import org.antlr.runtime.*;
<if(TREE_PARSER)>
import org.antlr.runtime.tree.*;
<endif>
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
<if(backtracking)>
import java.util.Map;
import java.util.HashMap;
<endif>
<@end>

<docComment>
@SuppressWarnings("all")
<recognizer>

>>

lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
      superClass="Lexer") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
	<tokens:{it | public static final int <it.name>=<it.type>;}; separator="\n">
	<scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
	<actions.lexer.members>

	// delegates
	<grammar.delegates:
		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
	// delegators
	<grammar.delegators:
		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
	public <superClass>[] getDelegates() {
		return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
	}

	public <grammar.recognizerName>() {} <! needed by subclasses !>
	public <grammar.recognizerName>(CharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
		this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
	}
	public <grammar.recognizerName>(CharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
		super(input,state);
<if(memoize)>
<if(grammar.grammarIsRoot)>
		state.ruleMemo = new HashMap[<numRules>+1];<\n> <! index from 1..n !>
<endif>
<endif>
		<grammar.directDelegates:
			{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
		<grammar.delegators:
			{g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
	}
	@Override public String getGrammarFileName() { return "<fileName>"; }

<if(filterMode)>
	<filteringNextToken()>
<endif>
	<rules; separator="\n\n">

	<synpreds:{p | <lexerSynpred(p)>}>

	<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
	<cyclicDFAs:cyclicDFA(); separator="\n\n"><! dump tables for all DFA !>

}
>>

/** A override of Lexer.nextToken() that backtracks over mTokens() looking
 *  for matches.  No error can be generated upon error; just rewind, consume
 *  a token and then try again.  backtracking needs to be set as well.
 *  Make rule memoization happen only at levels above 1 as we start mTokens
 *  at backtracking==1.
 */
filteringNextToken() ::= <<
public Token nextToken() {
	while (true) {
		if ( input.LA(1)==CharStream.EOF ) {
			Token eof = new CommonToken(input,Token.EOF,
										Token.DEFAULT_CHANNEL,
										input.index(),input.index());
			eof.setLine(getLine());
			eof.setCharPositionInLine(getCharPositionInLine());
			return eof;
		}
		state.token = null;
	state.channel = Token.DEFAULT_CHANNEL;
		state.tokenStartCharIndex = input.index();
		state.tokenStartCharPositionInLine = input.getCharPositionInLine();
		state.tokenStartLine = input.getLine();
	state.text = null;
		try {
			int m = input.mark();
			state.backtracking=1; <! means we won't throw slow exception !>
			state.failed=false;
			mTokens();
			state.backtracking=0;
			<! mTokens backtracks with synpred at backtracking==2
				and we set the synpredgate to allow actions at level 1. !>
			if ( state.failed ) {
				input.rewind(m);
				input.consume(); <! advance one char and try again !>
			}
			else {
				emit();
				return state.token;
			}
		}
		catch (RecognitionException re) {
			// shouldn't happen in backtracking mode, but...
			reportError(re);
			recover(re);
		}
	}
}

public void memoize(IntStream input,
		int ruleIndex,
		int ruleStartIndex)
{
if ( state.backtracking>1 ) super.memoize(input, ruleIndex, ruleStartIndex);
}

public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
if ( state.backtracking>1 ) return super.alreadyParsedRule(input, ruleIndex);
return false;
}
>>

actionGate() ::= "state.backtracking==0"

filteringActionGate() ::= "state.backtracking==1"

/** How to generate a parser */
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
              bitsets, inputStreamType, superClass,
              labelType, members, rewriteElementType,
              filterMode, ASTLabelType="Object") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
<if(grammar.grammarIsRoot)>
	public static final String[] tokenNames = new String[] {
		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
	};<\n>
<endif>
	<tokens:{it |public static final int <it.name>=<it.type>;}; separator="\n">

	// delegates
	<grammar.delegates: {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
	public <superClass>[] getDelegates() {
		return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
	}

	// delegators
	<grammar.delegators:
		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>

	<scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>

	<@members>
	<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
	public <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
		this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
	}
	public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
		super(input, state);
		<parserCtorBody()>
		<grammar.directDelegates:
			{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
		<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
	}
	<@end>

	@Override public String[] getTokenNames() { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; }
	@Override public String getGrammarFileName() { return "<fileName>"; }

	<members>

	<rules; separator="\n\n">

<! generate rule/method definitions for imported rules so they
   appear to be defined in this recognizer. !>
	// Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
	public <returnType(ruleDescriptor)> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec; separator=", "> { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">

	<synpreds:{p | <synpred(p)>}>

	<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
	<cyclicDFAs:cyclicDFA(); separator="\n\n"><! dump tables for all DFA !>

	<bitsets:{it | <bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
							words64=it.bits)>}; separator="\n">
}
>>

parserCtorBody() ::= <<
<if(memoize)>
<if(grammar.grammarIsRoot)>
this.state.ruleMemo = new HashMap[<length(grammar.allImportedRules)>+1];<\n> <! index from 1..n !>
<endif>
<endif>
<grammar.delegators:
	{g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
>>

parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
       ASTLabelType="Object", superClass="Parser", labelType="Token",
       members={<actions.parser.members>}) ::= <<
<genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
              bitsets, "TokenStream", superClass,
              labelType, members, "Token",
              false, ASTLabelType)>
>>

/** How to generate a tree parser; same as parser except the input
 *  stream is a different type.
 */
treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="Object",
           superClass={<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif>},
           members={<actions.treeparser.members>}
           ) ::= <<
<genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
              bitsets, "TreeNodeStream", superClass,
              labelType, members, "Node",
              filterMode, ASTLabelType)>
>>


@synpred.trapFailedBacktrack() ::= <<
try {
    // can never throw exception
    <@super.trapFailedBacktrack()>
} catch (RecognitionException re) {
    System.err.println("impossible: "+re);
}
boolean success = !state.failed;
>>

ruleMemoization(name) ::= <<
<if(memoize)>
if ( state.backtracking>0 && alreadyParsedRule(input, <ruleDescriptor.index>) ) { return <ruleReturnValue()>; }
<endif>
>>

/** How to test for failure and return from rule */
checkRuleBacktrackFailure() ::= <<
<if(backtracking)>if (state.failed) return <ruleReturnValue()>;<endif>
>>

/** This rule has failed, exit indicating failure during backtrack */
ruleBacktrackFailure() ::= <<
<if(backtracking)>if (state.backtracking>0) {state.failed=true; return <ruleReturnValue()>;}<endif>
>>

/** How to generate code for a rule.  This includes any return type
 *  data aggregates required for multiple return values.
 */
rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
<returnScope(scope=ruleDescriptor.returnScope)>

// $ANTLR start "<ruleName>"
// <fileName>:<description>
public final <returnType(ruleDescriptor)> <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec:{x|<x>}; separator=", "> {
	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
	<ruleScopeSetUp()>
	<ruleDeclarations()>
	<ruleLabelDefs()>
	<ruleDescriptor.actions.init>
	<@preamble()>
	try {
		<ruleMemoization(name=ruleName)>
		<block>
		<ruleCleanUp()>
		<(ruleDescriptor.actions.after):execAction()>
	}
<if(exceptions)>
	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
<else>
<if(!emptyRule)>
<if(actions.(actionScope).rulecatch)>
	<actions.(actionScope).rulecatch>
<else>
	catch (RecognitionException re) {
		reportError(re);
		recover(input,re);
		<@setErrorReturnValue()>
	}
<endif>
<endif>
<endif>
	finally {
		// do for sure before leaving
		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
		<memoize()>
		<ruleScopeCleanUp()>
		<finally>
	}
	<@postamble()>
	return <ruleReturnValue()>;
}
// $ANTLR end "<ruleName>"
>>

ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
retval.start = input.LT(1);
<else>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
<endif>
<if(memoize)>
int <ruleDescriptor.name>_StartIndex = input.index();
<endif>
>>

ruleScopeSetUp() ::= <<
<ruleDescriptor.useScopes:{it |<it>_stack.push(new <it>_scope());}; separator="\n">
<ruleDescriptor.ruleScope:{it |<it.name>_stack.push(new <it.name>_scope());}; separator="\n">
>>

ruleScopeCleanUp() ::= <<
<ruleDescriptor.useScopes:{it |<it>_stack.pop();}; separator="\n">
<ruleDescriptor.ruleScope:{it |<it.name>_stack.pop();}; separator="\n">
>>


lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
  ruleDescriptor.tokenListLabels,
  ruleDescriptor.ruleLabels]
	:{it |<labelType> <it.label.text>=null;}; separator="\n"
>
<ruleDescriptor.charLabels:{it |int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
  ruleDescriptor.ruleListLabels]
	:{it |List\<Object> list_<it.label.text>=null;}; separator="\n"
>
>>

ruleCleanUp() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<if(!TREE_PARSER)>
retval.stop = input.LT(-1);
<endif>
<endif>
>>

memoize() ::= <<
<if(memoize)>
<if(backtracking)>
if ( state.backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
<endif>
<endif>
>>

/** How to generate a rule in the lexer; naked blocks are used for
 *  fragment rules.
 */
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
// $ANTLR start "<ruleName>"
public final void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException {
	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
	<ruleScopeSetUp()>
	<ruleDeclarations()>
	try {
<if(nakedBlock)>
		<ruleMemoization(name=ruleName)>
		<lexerRuleLabelDefs()>
		<ruleDescriptor.actions.init>
		<block>
<else>
		int _type = <ruleName>;
		int _channel = DEFAULT_TOKEN_CHANNEL;
		<ruleMemoization(name=ruleName)>
		<lexerRuleLabelDefs()>
		<ruleDescriptor.actions.init>
		<block>
		<ruleCleanUp()>
		state.type = _type;
		state.channel = _channel;
		<(ruleDescriptor.actions.after):execAction()>
<endif>
	}
	finally {
		// do for sure before leaving
		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
		<ruleScopeCleanUp()>
		<memoize()>
	}
}
// $ANTLR end "<ruleName>"
>>

/** How to generate code for the implicitly-defined lexer grammar rule
 *  that chooses between lexer rules.
 */
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
@Override
public void mTokens() throws RecognitionException {
	<block>
}
>>

// S U B R U L E S

/** A (...) subrule with multiple alternatives */
block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
<rem()> <fileName>:<description>
<varDecl("int", {alt<decisionNumber>}, maxAlt)>
<decls>
<@predecision()>
<decision>
<@postdecision()>
<@prebranch()>
<switchStmt({alt<decisionNumber>}, alts:{a | <altSwitchCase(i,a)>})>
<@postbranch()>
>>

/** A rule block with multiple alternatives */
ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
<rem()> <fileName>:<description>
<varDecl("int", {alt<decisionNumber>}, maxAlt)>
<decls>
<@predecision()>
<decision>
<@postdecision()>
<switchStmt({alt<decisionNumber>}, alts:{a | <altSwitchCase(i,a)>})>
>>

/** A (..)+ block with 1 or more alternatives */
positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
// <fileName>:<description>
int cnt<decisionNumber>=0;
<decls>
<@preloop()>
loop<decisionNumber>:
do {
	int alt<decisionNumber>=<maxAlt>;
	<@predecision()>
	<decision>
	<@postdecision()>
	switch (alt<decisionNumber>) {
	<alts:{a | <altSwitchCase(i,a)>}>
	default :
		if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
		<ruleBacktrackFailure()>
			EarlyExitException eee =
				new EarlyExitException(<decisionNumber>, input);
			<@earlyExitException()>
			throw eee;
	}
	cnt<decisionNumber>++;
} while (true);
<@postloop()>
>>

positiveClosureBlockSingleAlt ::= positiveClosureBlock

/** A (..)* block with 1 or more alternatives */
closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
// <fileName>:<description>
<decls>
<@preloop()>
loop<decisionNumber>:
do {
	int alt<decisionNumber>=<maxAlt>;
	<@predecision()>
	<decision>
	<@postdecision()>
	switch (alt<decisionNumber>) {
	<alts:{a | <altSwitchCase(i,a)>}>
	default :
		break loop<decisionNumber>;
	}
} while (true);
<@postloop()>
>>

closureBlockSingleAlt ::= closureBlock

/** Optional blocks (x)? are translated to (x|) by before code generation
 *  so we can just use the normal block template
 */
optionalBlock ::= block

optionalBlockSingleAlt ::= block

/** An alternative is just a list of elements; at outermost level */
alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
// <fileName>:<description>
{
<@declarations()>
<elements:element()>
<rew>
<@cleanup()>
}
>>

// E L E M E N T S

/** Dump the elements one per line */
element(e) ::= <<
<@prematch()>
<e.el>
>>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
<if(label)><label>=(<labelType>)<endif>match(input,<token>,FOLLOW_<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(token,label,elementIndex,terminalOptions)>
<listLabel(label, label)>
>>

listLabel(label,elem) ::= <<
if (list_<label>==null) list_<label>=new ArrayList\<Object>();
list_<label>.add(<elem>);
>>

/** match a character */
charRef(char,label) ::= <<
<if(label)>
<label> = input.LA(1);
<endif>
match(<char>); <checkRuleBacktrackFailure()>
>>

/** match a character range */
charRangeRef(a,b,label) ::= <<
<if(label)>
<label> = input.LA(1);
<endif>
matchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label,elementIndex,terminalOptions,postmatchCode="") ::= <<
<if(label)>
<if(LEXER)>
<label> = input.LA(1);
<else>
<label> = (<labelType>)input.LT(1);
<endif>
<endif>
if ( <s> ) {
	input.consume();
	<postmatchCode>
<if(!LEXER)>
	state.errorRecovery=false;
<endif>
	<if(backtracking)>state.failed=false;<endif>
}
else {
	<ruleBacktrackFailure()>
	MismatchedSetException mse = new MismatchedSetException(null,input);
	<@mismatchedSetException()>
<if(LEXER)>
	recover(mse);
	throw mse;
<else>
	throw mse;
	<! use following code to make it recover inline; remove throw mse;
	recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
	!>
<endif>
}
>>

matchRuleBlockSet ::= matchSet

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
<matchSet(...)>
<listLabel(label, label)>
>>

/** Match a string literal */
lexerStringRef(string,label,elementIndex="0") ::= <<
<if(label)>
int <label>Start = getCharIndex();
match(<string>); <checkRuleBacktrackFailure()>
int <label>StartLine<elementIndex> = getLine();
int <label>StartCharPos<elementIndex> = getCharPositionInLine();
<label> = new <labelType>(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start, getCharIndex()-1);
<label>.setLine(<label>StartLine<elementIndex>);
<label>.setCharPositionInLine(<label>StartCharPos<elementIndex>);
<else>
match(<string>); <checkRuleBacktrackFailure()>
<endif>
>>

wildcard(token,label,elementIndex,terminalOptions) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);
<endif>
matchAny(input); <checkRuleBacktrackFailure()>
>>

wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<wildcard(...)>
<listLabel(label, label)>
>>

/** Match . wildcard in lexer */
wildcardChar(label, elementIndex) ::= <<
<if(label)>
<label> = input.LA(1);
<endif>
matchAny(); <checkRuleBacktrackFailure()>
>>

wildcardCharListLabel(label, elementIndex) ::= <<
<wildcardChar(label, elementIndex)>
<listLabel(label, label)>
>>

/** Match a rule reference by invoking it possibly with arguments
 *  and a return value or values.  The 'rule' argument was the
 *  target rule name, but now is type Rule, whose toString is
 *  same: the rule name.  Now though you can access full rule
 *  descriptor stuff.
 */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
pushFollow(FOLLOW_<rule.name>_in_<ruleName><elementIndex>);
<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name>(<args; separator=", ">);
state._fsp--;
<checkRuleBacktrackFailure()>
>>

/** ids+=r */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(rule,label,elementIndex,args,scope)>
<listLabel(label, label)>
>>

/** A lexer rule reference.
 *
 *  The 'rule' argument was the target rule name, but now
 *  is type Rule, whose toString is same: the rule name.
 *  Now though you can access full rule descriptor stuff.
 */
lexerRuleRef(rule,label,args,elementIndex,scope) ::= <<
<if(label)>
int <label>Start<elementIndex> = getCharIndex();
int <label>StartLine<elementIndex> = getLine();
int <label>StartCharPos<elementIndex> = getCharPositionInLine();
<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
<label> = new <labelType>(input, Token.INVALID_TOKEN_TYPE, Token.DEFAULT_CHANNEL, <label>Start<elementIndex>, getCharIndex()-1);
<label>.setLine(<label>StartLine<elementIndex>);
<label>.setCharPositionInLine(<label>StartCharPos<elementIndex>);
<else>
<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
<endif>
>>

/** i+=INT in lexer */
lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
<lexerRuleRef(rule,label,args,elementIndex,scope)>
<listLabel(label, label)>
>>

/** EOF in the lexer */
lexerMatchEOF(label,elementIndex) ::= <<
<if(label)>
int <label>Start<elementIndex> = getCharIndex();
int <label>StartLine<elementIndex> = getLine();
int <label>StartCharPos<elementIndex> = getCharPositionInLine();
match(EOF); <checkRuleBacktrackFailure()>
<labelType> <label> = new <labelType>(input, EOF, Token.DEFAULT_CHANNEL, <label>Start<elementIndex>, getCharIndex()-1);
<label>.setLine(<label>StartLine<elementIndex>);
<label>.setCharPositionInLine(<label>StartCharPos<elementIndex>);
<else>
match(EOF); <checkRuleBacktrackFailure()>
<endif>
>>

// used for left-recursive rules
recRuleDefArg()                       ::= "int <recRuleArg()>"
recRuleArg()                          ::= "_p"
recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
recRuleSetReturnAction(src,name)      ::= "$<name>=$<src>.<name>;"

/** match ^(root children) in tree parser */
tree(root, actionsAfterRoot, children, nullableChildList,
     enclosingTreeLevel, treeLevel) ::= <<
<root:element()>
<actionsAfterRoot:element()>
<if(nullableChildList)>
if ( input.LA(1)==Token.DOWN ) {
	match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
	<children:element()>
	match(input, Token.UP, null); <checkRuleBacktrackFailure()>
}
<else>
match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
<children:element()>
match(input, Token.UP, null); <checkRuleBacktrackFailure()>
<endif>
>>

/** Every predicate is used as a validating predicate (even when it is
 *  also hoisted into a prediction expression).
 */
validateSemanticPredicate(pred,description) ::= <<
if ( !(<evalPredicate(pred,description)>) ) {
	<ruleBacktrackFailure()>
	throw new FailedPredicateException(input, "<ruleName>", "<description>");
}
>>

// F i x e d  D F A  (if-then-else)

@dfaState.newNVAE() ::= <<
<(nvaExceptionWrapperMap.(k))({
NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
<@super.newNVAE()>
})>
>>

nvaExceptionWrapperMap ::= [
	"1":"wrapNvaExceptionForK1",
	"2":"wrapNvaExceptionForK2",
	default:"wrapNvaExceptionForKN"
]

wrapNvaExceptionForK1(exceptionCode) ::= <<
<exceptionCode>
>>

wrapNvaExceptionForK2(exceptionCode) ::= <<
int nvaeMark = input.mark();
try {
	input.consume();
	<exceptionCode>
} finally {
	input.rewind(nvaeMark);
}
>>

wrapNvaExceptionForKN(exceptionCode) ::= <<
int nvaeMark = input.mark();
try {
	for (int nvaeConsume = 0; nvaeConsume \< <k> - 1; nvaeConsume++) {
		input.consume();
    }
	<exceptionCode>
} finally {
	input.rewind(nvaeMark);
}
>>


// F i x e d  D F A  (switch case)

/** A DFA state where a SWITCH may be generated.  The code generator
 *  decides if this is possible: CodeGenerator.canGenerateSwitch().
 */
dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
<switchStmt({input.LA(<k>)}, edges, {
<if(eotPredictsAlt)>
	alt<decisionNumber>=<eotPredictsAlt>;
<else>
	<ruleBacktrackFailure()>
	<(nvaExceptionWrapperMap.(k))({NoViableAltException nvae =
	new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
<@noViableAltException()>
throw nvae;})>
<endif>
})>
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ( input.LA(<k>) ) {
	<edges; separator="\n">
}
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ( input.LA(<k>) ) {
<edges; separator="\n">
<if(eotPredictsAlt)>
default:
	alt<decisionNumber>=<eotPredictsAlt>;
	break;
<endif>
}
>>

dfaEdgeSwitch(labels, targetState) ::= <<
<labels:{it |case <it>:}; separator="\n">
	{
	<targetState>
	}
	break;
>>

// C y c l i c  D F A

/** The code to initiate execution of a cyclic DFA; this is used
 *  in the rule to predict an alt just like the fixed DFA case.
 *  The <name> attribute is inherited via the parser, lexer, ...
 */
dfaDecision(decisionNumber,description,parameters) ::= <<
alt<decisionNumber> = dfa<decisionNumber>.predict(input<if(parameters)>, <parameters:parametersCall()><endif>);
>>

/* Dump DFA tables as run-length-encoded Strings of octal values.
 * Can't use hex as compiler translates them before compilation.
 * These strings are split into multiple, concatenated strings.
 * Java puts them back together at compile time thankfully.
 * Java cannot handle large static arrays, so we're stuck with this
 * encode/decode approach.  See analysis and runtime DFA for
 * the encoding methods.
 */
cyclicDFA(dfa) ::= <<
static final String DFA<dfa.decisionNumber>_eotS =
	"<dfa.javaCompressedEOT; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_eofS =
	"<dfa.javaCompressedEOF; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_minS =
	"<dfa.javaCompressedMin; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_maxS =
	"<dfa.javaCompressedMax; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_acceptS =
	"<dfa.javaCompressedAccept; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_specialS =
	"<dfa.javaCompressedSpecial; wrap="\"+\n\t\"">}>";
static final String[] DFA<dfa.decisionNumber>_transitionS = {
		<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
};

static final short[] DFA<dfa.decisionNumber>_eot = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_eotS);
static final short[] DFA<dfa.decisionNumber>_eof = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_eofS);
static final char[] DFA<dfa.decisionNumber>_min = DFA.unpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
static final char[] DFA<dfa.decisionNumber>_max = DFA.unpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
static final short[] DFA<dfa.decisionNumber>_accept = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
static final short[] DFA<dfa.decisionNumber>_special = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_specialS);
static final short[][] DFA<dfa.decisionNumber>_transition;

static {
	int numStates = DFA<dfa.decisionNumber>_transitionS.length;
	DFA<dfa.decisionNumber>_transition = new short[numStates][];
	for (int i=0; i\<numStates; i++) {
		DFA<dfa.decisionNumber>_transition[i] = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
	}
}

class DFA<dfa.decisionNumber> extends DFA {

	public DFA<dfa.decisionNumber>(BaseRecognizer recognizer) {
		this.recognizer = recognizer;
		this.decisionNumber = <dfa.decisionNumber>;
		this.eot = DFA<dfa.decisionNumber>_eot;
		this.eof = DFA<dfa.decisionNumber>_eof;
		this.min = DFA<dfa.decisionNumber>_min;
		this.max = DFA<dfa.decisionNumber>_max;
		this.accept = DFA<dfa.decisionNumber>_accept;
		this.special = DFA<dfa.decisionNumber>_special;
		this.transition = DFA<dfa.decisionNumber>_transition;
	}
	@Override
	public String getDescription() {
		return "<dfa.description>";
	}
	<@errorMethod()>
<if(dfa.specialStateSTs)>
    <specialStateTransition(dfa.decisionNFAStartState.enclosingRule.parameterScope)>
<endif>
}
>>

specialStateTransition(parameters) ::= <<
	@Override
<if(parameters)>
	public int specialStateTransition(int s, IntStream _input, Object ... args) throws NoViableAltException {
        return _specialStateTransition(s, _input, <parameters:parametersCast("args")>);
    }

	public int _specialStateTransition(int s, IntStream _input, <parameters:parameterScope()>) throws NoViableAltException {
<else>
    public int specialStateTransition(int s, IntStream _input, Object ... ignored) throws NoViableAltException {
<endif>
		<if(LEXER)>
		IntStream input = _input;
		<endif>
		<if(PARSER)>
		TokenStream input = (TokenStream)_input;
		<endif>
		<if(TREE_PARSER)>
		TreeNodeStream input = (TreeNodeStream)_input;
		<endif>
		int _s = s;
		switch ( s ) {
		<dfa.specialStateSTs:{state |
		case <i0> : <! compressed special state numbers 0..n-1 !>
			<state>}; separator="\n">
		}
<if(backtracking)>
		if (state.backtracking>0) {state.failed=true; return -1;}
<endif>
		NoViableAltException nvae =
			new NoViableAltException(getDescription(), <dfa.decisionNumber>, _s, input);
		error(nvae);
		throw nvae;
	}
>>

/** A state in a cyclic DFA; it's a special state and part of a big switch on
 *  state.
 */
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(1);
<if(semPredState)> <! get next lookahead symbol to test edges, then rewind !>
int index<decisionNumber>_<stateNumber> = input.index();
input.rewind();
<endif>
s = -1;
<edges; separator="\nelse ">
<if(semPredState)> <! return input cursor to state before we rewound !>
input.seek(index<decisionNumber>_<stateNumber>);
<endif>
if ( s>=0 ) return s;
break;
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
 *  state to jump to next if successful.
 */
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
if ( (<labelExpr>)<if(predicates)> && (<predicates>)<endif> ) {s = <targetStateNumber>;}
>>

/** An edge pointing at end-of-token; essentially matches any char;
 *  always jump to the target.
 */
eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
s = <targetStateNumber>;
>>


// D F A  E X P R E S S I O N S

andPredicates(operands) ::= <%<naryOperator(operands, "&&")>%>

orPredicates(operands)  ::= <%<naryOperator(operands, "||")>%>

naryOperator(operands, operator) ::= "(<first(operands)>)<rest(operands):{o |<operator>(<o>)}>"

notPredicate(pred) ::= "!(<pred>)"

evalPredicate(pred,description) ::= "<pred>"

evalPredicateGroup(pred) ::= "(<pred>)"

evalSynPredicate(pred,description) ::= "<pred>()"

// A T T R I B U T E S

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
	<scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();
<endif>
>>

ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
	<scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();
<endif>
>>

returnType(ruleDescriptor) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
<elseif(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
%>

/** Generate the Java type associated with a single or multiple return
 *  values.
 */
ruleLabelType(referencedRule) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
<returnScopeBaseType()>
<elseif(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
%>

delegateName(d) ::= <<
<if(d.label)><d.label><else>g<d.name><endif>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<javaTypeInitMap.(typeName)>
>>

/** Define a return struct for a rule if the code needs to access its
 *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
 *  subgroups to stick in members.
 */
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
public static class <ruleDescriptor:returnStructName()> extends <returnScopeBaseType()> {
	<scope.attributes:{it |public <it.decl>;}; separator="\n">
	<@ruleReturnMembers()>
};
<endif>
>>

returnScopeBaseType() ::= <%
<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope
%>

parametersCast(scope,varName) ::= <<
<scope.attributes:{it | (<if(javaPrimitiveTypeCastMap.(it.type))><javaPrimitiveTypeCastMap.(it.type)><else><it.type><endif>)<varName>[<i0>]}; separator=", ">
>>

scopeAttributeRef(scope,attr,index,negIndex) ::= <%
<if(negIndex)>
<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1).<attr.name>
<else>
<if(index)>
<scope>_stack.elementAt(<index>).<attr.name>
<else>
<scope>_stack.peek().<attr.name>
<endif>
<endif>
%>

scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
<if(negIndex)>
<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1).<attr.name> = <expr>;
<else>
<if(index)>
<scope>_stack.elementAt(<index>).<attr.name> = <expr>;
<else>
<scope>_stack.peek().<attr.name> = <expr>;
<endif>
<endif>
%>

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= "<if(referencedRule.hasMultipleReturnValues)><nullSafe(val=scope,attr=attr.name,nullval={<initValue(attr.type)>})><else><scope><endif>"

returnAttributeRef(ruleDescriptor,attr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name>
<else>
<attr.name>
<endif>
%>

returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name> = <expr>;
<else>
<attr.name> = <expr>;
<endif>
%>

// not sure the next are the right approach

tokenLabelPropertyRef_text(scope,attr) ::= <%<nullSafe(scope,"getText()")>%>
tokenLabelPropertyRef_type(scope,attr) ::= <%<nullSafe(var=scope,attr="getType()",nullval="0")>%>
tokenLabelPropertyRef_line(scope,attr) ::= <%<nullSafe(var=scope,attr="getLine()",nullval="0")>%>
tokenLabelPropertyRef_pos(scope,attr) ::= <%<nullSafe(var=scope,attr="getCharPositionInLine()",nullval="0")>%>
tokenLabelPropertyRef_channel(scope,attr) ::= <%<nullSafe(var=scope,attr="getChannel()",nullval="0")>%>
tokenLabelPropertyRef_index(scope,attr) ::= <%<nullSafe(var=scope,attr="getTokenIndex()",nullval="0")>%>
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
tokenLabelPropertyRef_int(scope,attr) ::= <%<nullSafe(var=scope,expr={Integer.valueOf(<scope>.getText())},nullval="0")>%>

scopeAttrRef(scope,attr) ::= "<nullSafe(...)>"

ruleLabelPropertyRef_start ::= scopeAttrRef
ruleLabelPropertyRef_stop ::= scopeAttrRef
ruleLabelPropertyRef_tree(scope,attr) ::= <%<nullSafe(scope,"getTree()")>%>
ruleLabelPropertyRef_text(scope,attr) ::= <%
<nullSafe(var=scope, expr={
<if(TREE_PARSER)>
input.getTokenStream().toString(
  input.getTreeAdaptor().getTokenStartIndex(<scope>.start), 
  input.getTreeAdaptor().getTokenStopIndex(<scope>.start))
<else>
input.toString(<scope>.start, <scope>.stop)
<endif>})>
%>

ruleLabelPropertyRef_st(scope,attr) ::= <%<nullSafe(var=scope,expr={(StringTemplate)<scope>.getTemplate()})>%>

lexerRuleLabelPropertyRef_type(scope,attr) ::= <%<nullSafe(var=scope,attr="getType()",nullval="0")>%>
lexerRuleLabelPropertyRef_line(scope,attr) ::= <%<nullSafe(var=scope,attr="getLine()",nullval="0")>%>
lexerRuleLabelPropertyRef_pos(scope,attr) ::= <%<nullSafe(var=scope,attr="getCharPositionInLine()",nullval="-1")>%>
lexerRuleLabelPropertyRef_channel(scope,attr) ::= <%<nullSafe(var=scope,attr="getChannel()",nullval="0")>%>
lexerRuleLabelPropertyRef_index(scope,attr) ::= <%<nullSafe(var=scope,attr="getTokenIndex()",nullval="0")>%>
lexerRuleLabelPropertyRef_text(scope,attr) ::= <%<nullSafe(scope,"getText()")>%>
lexerRuleLabelPropertyRef_int(scope,attr) ::= <%<nullSafe(var=scope,expr={Integer.valueOf(<scope>.getText())},nullval="0")>%>

// Somebody may ref $template or $tree or $stop within a rule:
rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval.start)"
rulePropertyRef_stop(scope,attr) ::= "((<labelType>)retval.stop)"
rulePropertyRef_tree(scope,attr) ::= "((<ASTLabelType>)retval.tree)"
rulePropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
input.getTokenStream().toString(
  input.getTreeAdaptor().getTokenStartIndex(retval.start),
  input.getTreeAdaptor().getTokenStopIndex(retval.start))
<else>
input.toString(retval.start,input.LT(-1))
<endif>
%>
rulePropertyRef_st(scope,attr) ::= "retval.st"

lexerRulePropertyRef_text(scope,attr) ::= "getText()"
lexerRulePropertyRef_type(scope,attr) ::= "_type"
lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
lexerRulePropertyRef_stop(scope,attr) ::= "(getCharIndex()-1)"
lexerRulePropertyRef_int(scope,attr) ::= "Integer.valueOf(<scope>.getText())"

// setting $st and $tree is allowed in local rule. everything else
// is flagged as error
ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.tree = <expr>;"
ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.st = <expr>;"

// M I S C (properties, etc...)

bitset(name, words64) ::= <<
public static final BitSet <name> = new BitSet(new long[]{<words64:{it |<it>L};separator=",">});
>>

codeFileExtension() ::= ".java"
